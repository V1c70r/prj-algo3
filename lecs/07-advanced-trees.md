# Специализированные деревья

## B-деревья

B-деревья — обобщение сбаллансированных бинарных поисковых деревьев, которое используется для более эффективной работы в системах, имееющих большую латентность при переходе от одного блока данных к другим (при чтении данных из разных секторов диска, обращении к оперативной памяти по сравнению с обращением к кешу процессора, чтением по сети по сравнению с локальных чтением). В этих деревьях в одном блоке хранится не 1 ключ (ключ-значение), а k, которое на практике порядка 100-1000. Это делает дерево очень плоским, но все же сохраняет огарифмическую сложность всех операций.

Основное применение — индексы в СУБД. 

## R-деревья

R-деревья (rectangular - деревья прямоугольников) — дерево вложенных прямоугольников/параллелограммов/... (в зависимости от размерности пространства), которое позволяет быстро находить все объекты, которые относятся к той или иной части пространства. Используется в пространственных вычислениях (в т.ч. картографии). Основная алгоритмическая сложность — эффективное разбиение пространства на прямоугольники так, чтобы они имели наименьший периметр, занимали наименьшую площадь и имели минимальное перекрытие. Для этого используются различные эвристики разбиения дерева.

## Kd-деревья

Деревья, которые позволяют быстро находить примерное множется ближайших соседей для любой точки n-мерного пространства. Такие деревья строятся для статических наборов данных по следующему принципу: для текущего набора элементов выбирается одна из координат и по ней выбирается медианное значение (т.е. половина элементов имеют значение этой координаты меньше этого, а половина — больше). Это позволяет разбить текцщее множество на 2 подмножества примерно равных размеров. Такое деление может продолжаться пока не будут задействованны все координаты или же еще дальше до тех пор, пока размеры подмножеств не будут равны заданному числу.

## Префиксные деревья

Префиксные деревья (trie) позволяют эффективно с точки зрения занимаемого места и времени поиска представлять большие наборы ключей-строк/последовательностей. В этих деревьях каждый ключ представляется в виде пути в дереве, в узлах которого последовательно находятся эллементы или же подпоследовательности ключа. Это позволяет осуществлять поиск за время меньше равное длине искомой последовательности. Также такие деревья поддерживают эффективно поиск близких последовательностей (с одинаковым префиксом, а также, при использовании двух деревьев - и любых).

## Эффективное представление динамических строк

Строки, которые создаются и модифицируются динамически, требуют более эффективной стркутуры данных для представления, чем обычный одномерный массив, т.к. операция изменения внутри массива имеет сложность O(n). Для разных сценариев работы могут использоваться разные структуры.

Простой вариант — это *массив с разрывом* (gap buffer), который, фактически моделирует курсов. В этом массиве в каждый момент времени выделено дополнительное место, которое не занято символами текушей строки. Этот зазор (незаполненные ячейки) находится в том месте в массиве, где в данном случае находится фокус или курсов. Это позволяет выполнять операции модификации и перемещения за амортизированное константное время. Вставка или удаление символа в текущей позици — O(1) (когда зазор заканчивается происходит выделение дополнительного места). Переход в другое место — также O(1), т.к. может осуществляться с помощью операции `memcpy` заполненного участка буфера, который находится между старым и новым положением курсора так, чтобы зазор поменялся местами с этим участком.

Альтернативный вариант предтавления динамаической строки — это *веревка* (rope) — бинарное дерево, в листьях которого находятся последовательные подстроки строки (как правило, новый лист формируется после очередной серии вставки элементов в строку), а в вершинах — совокупная длина подстроки левого поддерева. Это позволяет найти символ в текущей позиции за O(log n), а также с такиой же сложностей выполнять добавление или удаление новых подстрок. 


## Литература

- https://cathyatseneca.gitbooks.io/data-structures-and-algorithms/content/2-3_trees/index.html
- http://www.scholarpedia.org/article/B-tree_and_UB-tree
- https://habrahabr.ru/post/224965/
- https://www.gaia-gis.it/gaia-sins/spatialite-cookbook/html/rtree.html
- http://chairnerd.seatgeek.com/spatial-data-structures-for-better-map-interactions/
- http://gist.cs.berkeley.edu/gist1.html
- https://habrahabr.ru/post/115026/
- https://www.cise.ufl.edu/class/cot5520fa09/CG_RangeKDtrees.pdf
- https://medium.com/algorithms/trie-prefix-tree-algorithm-ee7ab3fe3413
- http://scienceblogs.com/goodmath/2009/02/18/gap-buffers-or-why-bother-with-1/
- https://www.ibm.com/developerworks/library/j-ropes/
- https://www.slideshare.net/madAlgorithmist/mysql-performance-optimization-indexing-algorithms-and-data-structures-14041930
- http://guide.couchdb.org/draft/btree.html
- http://www.aosabook.org/en/bdb.html
