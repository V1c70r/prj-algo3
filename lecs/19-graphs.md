# Задачи на графах

## Минимальное остовное дерево (MST)

**Минимальное остовное дерево** взвешенного ненаправленного графа — это дерево (или лес деревьев для графа с несколькими компонентами связности), которое включает все вершины графа и имеет минмиальную длину.

Эта задача интересна тем, что она может эффективно решаться с помощью жадных алгоритмов.

### Алгоритм Прима

Алгоритм Прима случайным образом берет стартовую вершину и на каждом шаге выбирает кратчайшее ребро, которое связывает вершины, уже добавленные в дерево с вершинами, которые доступны из них. Таким образом, на каждом шаге алгоритма рассматривается 3 множеста: добавленных вершин, доступных (пограничных) вершин и пока недоступных вершин. Ключ к эффективной реализации алгоритма — эффективный выбор кратчайшего ребра, соединяющего доступные и пограничные вершины. Наиболее удачный вариант — это куча Фибоначчи, содержащая все непросмотренные вершины и расстояния до них из просмотренных вершин, которые обновляются при добавлении каждой новой варшины.

Сложность алгоритма (`V` — количество вершин, `E` — количество ребер):

- при использовании просто списка ребер: `O(V^2)`
- при использовании кучи Фибоначчи: `O(E * logV)`

### Алгоритм Краскала

Алгоритм Краскала выбирает по очереди наименьшие ребра и добавляет их в список ребер будущего дерева, если они не образуют цикла. Ключ к эффективной реализации — проверка на образование цикла. Это может быть сделано с помощью структуры для хранения непересекающихся множеств (как правило, Union-Find).

Структура Union-Find поддерживает 2 операции:

- `Find(A)` возвращает идентификатор множества, к которому принадлежит элемент A
- `Union(A, B)` объединяет множества, к которым относится `A` и `B`. Т.е., если до Union `Find(A) = X`, а `Find(A) = Y`, то после — обе операции должны возвращать либо `X`, либо `Y`


## Макисмальный поток / минимальный разрез

Направленный взвешенный граф называется транспортной сетью, если у него есть вершина-исток, у которой есть только исходящие ребра, и вершина-сток, у которой есть только входящие. Поток в этой сети — это количество единиц, которые проходят по всем ребрам из истока и входят во все ребра стока. Вес каждого ребра в такой сети — это его максимальная пропускная способность. В такой сети можно ввести условие баланса: входящий поток любой вершины (кроме истока и стока) должен равняться исходящему. В таком случае весь поток, который исходит из истока, будет передан в сток.

Задача поиска максимального потока в направленном взвешенном графе состоит в том, чтобы найти максимально возможную величину такого потока.

Для ее решения применяется алгоритм Форда-Фулкерсона и его вариации (Эдмондса-Карпа, Диница и др). Идея алгоритма следующая: поседовательный перебор всех маршрутов в сети с отниманием величины потока по ним от их ребер и прибавлением его к результирующему потоку сети до тех пор, пока такие пути существуют. Поскольку каждый новый путь увеличивает результирующий поток, эта процедура закончиться максимум за F шагов, где F — величина максимального потока. Вариации алгоритма оптимизируют порядок перебора путей (например, выбирая самый короткий путь по количеству ребер или самый жирный путь).

Решив задачу максимального потока также можно решить задачу минимального разреза (min cut), а также двудольного сопоставления (bipartite matching).


## Литература

- http://www3.cs.stonybrook.edu/~algorith/video-lectures/2007/lecture13.pdf
- http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/
- http://stackoverflow.com/questions/1195872/kruskal-vs-prim
- https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf
- https://stackoverflow.com/questions/19508526/what-is-the-intuition-behind-the-fibonacci-heap-data-structure
- http://www.cs.princeton.edu/courses/archive/spr04/cos226/lectures/maxflow.4up.pdf
- http://rosulek.github.io/vamonos/demos/max-flow.html
- https://web.stanford.edu/class/cs97si/08-network-flow-problems.pdf
- http://www.mathcs.emory.edu/~cheung/Courses/323/Syllabus/NetFlow/max-flow-lp.html
- [Скринкаст с демонстрацией программирования алгоритма](https://youtu.be/5ugyXbcXrjs)
