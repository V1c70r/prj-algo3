# Хеш-таблицы

## Cтруктуры типа ключ-значение

Ключ-значение — это одна из трех базовых фундаментальных абстрактных структур данных наряду с последовательностями и кортежами (structs/records). Она может применяться для:

- key-value store
- представление любых словарей
- эффективная реализация (мульти)множеств
- мемоизация

Варианты реализации структуры ключ-значение:

- список/массив пар (ассоциативный массив)
- хеш-таблица
- поисковое дерево

Хеш-таблицы — это основанные на массивах структуры данных, которые имеют амортизированную сложность основных (вставка, модификация, удаление) операций — `O(1)`. Однако это происходит за счет следующих особенностей:

- данные в хеш-таблице не могут быть упорядоченны произвольным образом
- хотя время доступа к элементам и является константой, но сама константа может быть достаточно большой
- в хеш-таблицах, как правило, происходит не полностью эффективное использование памяти (потери могут составлять от 30 до 50%)
- таблицы не поддерживают эффективно такие операции как поиск наибольшего элемента (хотя есть варианты, такие как Linked Hash Table)

Хеш-таблица создается на основе массива добавлением операции хеширования ключа, в результате которой можно узнать элемент массива, где должна находится пара ключ-значение. При этом разные ключи могут давать одинаковый хеш-код, что приводит к коллизиям (невозможности записать или найти элемент в точности в указанной хеш-функцией ячейке). 

Варианты реализации хеш-таблиц с учетом борьбы с коллизиями:

- цепная — если в какую-то ячейку должен быть записан более, чем 1 элемент, то эти элементы размещаются в дополнительной структуре, которая может быть:
  - связным списком/динамическим массивом
  - деревом
  - еще одной хеш-таблицей (возможно, с другой хеш-функцией)
- открытая адресация — если ячейка занята, то мы смотрим на соседей и ищем среди них пустую ячейку или же нужный нам ключ и так по рекурсии. Варианты реализации:
  - линейная/квадратичная
  - двойное хеширование
  - гибрид линейной модели и двойного хеширования
  - кукушечная
  - hopscotch
  - 2-х вариантный

Цепная реализация хеш-таблиц позволяет хранить в таблице неограниченный объем данных, но в этом случае таблица вырождается в множество списков или деревьев.

Хеш-таблицы с открытой адресацией более простые и эффективные, но могут хранить не больше значений, чем размер массива. При этом при превышении заполненности массива 0.7-0.8 у них существенно падает производительность. Для борьбы с такой ситуацией используется динамическое расширение (для этого также есть разные стратегии).

## Литература

- http://www.lkozma.net/cuckoo_hashing_visualization/
- http://stackoverflow.com/questions/10256974/under-the-hood-are-javascript-objects-hash-tables
- http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html
- http://stackoverflow.com/questions/21126507/why-does-sxhash-return-a-constant-for-all-structs


# Хеш-функции

Задачи (некриптографической) хеш-функции:

- сократить диапазон ключей до размера массива хеш-таблицы
- перераспределить ключи примерно равномерно
- при этом хеши соседних ключей должны, в идеале, оказаться далеко друг от друга

Простейший вариант хеш-функции: битовая маска, которая берет только несколько бит из численного представления данных.

Большинство хеш-функций используют последовательное преобразование данных путем сложения, усножения и операции `xor` с последующим делением по модулю, чтобы результат оказался в требуемом интервале.

Хеш-функции, как правило, являются необратимыми.


## Литература

- https://betterexplained.com/articles/understanding-the-birthday-paradox/
- http://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed
- http://stackoverflow.com/questions/2624192/good-hash-function-for-strings
- http://computinglife.wordpress.com/2008/11/20/why-do-hash-functions-use-prime-numbers/
- http://isthe.com/chongo/tech/comp/fnv/
- https://habrahabr.ru/post/120562/


# Кеширование

Кеш — это компонент компьютерной системы, который прозрачно хранит данные так, чтобы последующие запросы к ним могли быть удовлетворены быстрее. Наличие кеша подразумевает также наличие запоминающего устройства (гораздо) большего размера, в которых данные хранятся изначально, либо медленной функции вычисления данных. Запросы на получение данных из этого устройства прозрачно
проходят через кеш в том смысле, что если этих данных нет в кеше, то они запрашиваются из основного устройства (или же осуществляется вызов функции) и параллельно записываются в кеш.

Соответственно, при последующем обращении данные могут быть извлечены уже из кеша. За счет намного меньшего размера кеш может быть сделан намного быстрее и в этом основная цель его существования.

По принципу записи данных в кеш выделяют:

- сквозной (write-through) — данные записываются синхронно и в кеш, и непосредственно в запоминающее устрйоство
- с обратной записью (write-back, write-behind) — данные записываются в кещ и иногда синхронизируются с запоминающим устройством

Кроме начального момента включения кеша в работу (т.н. прогрева), кеш всегда находится в полностью заполненном состоянии. Это значит, что при появлении новых данных, чтобы записать их в кеш, нужно удалить из него одну из записей. Идеальный алгоритм выбора кандидата на удаление должен бы был предсказывать запись, которая имеет наименьшукю вероятность быть запрошенной в будущем. В общем случае, это не возможно, поэтому на практике могут использоваться различные алгоритмы, которые ставят целью наилучшим образом апроксимировать это предсказание:

- "часы"
- второй шанс
- LFU
- LRU
- LRFU



## Литература

- http://stackoverflow.com/questions/1188587/cache-invalidation-is-there-a-general-solution
- https://en.wikipedia.org/wiki/Cache_replacement_policies
- http://antirez.com/news/109
- http://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips
